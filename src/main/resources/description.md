Первый этап это компиляция исходного кода из файла `.java` в байткод в файл с расширением `.class` через программу
компилятор `javac`. После компиляции будут запущены загрузчики классов ( classLoaders ), которые будут искать наш
класс `Main` сначала в библиотеках самого языка через `Bootstrap classloader`, потом в библиотеках платформы через `Platform
classloader`, а в конце через загрузчик `Application classloader`, который наш класс найдёт и загрузит в область оперативной
памяти под названием `Meta space`.

В случае, если ни один из загрузчиков не найдёт класс, вернётся исключение `ClassNotFoundException`.

В нашем случае на загрузку пойдёт 3 класса `Main` и `Object`. Main загрузит `Application classloader`, 
Object и System загрузит `Bootstrap classloader`.

Далее переходим к этапу линковка (Linking) где: 
1) Verify проводится валидация кода на ошибки
2) Prepare подготавливаются примитивы в статических полях и логических блоках.
3) Resolve происходит связывание символьных ссылок на другие классы

После чего код переходит к этапу инициализации (Initialization). Здесь статические блоки и статические поля выполняются 
им присваивается значение, выполняется код внутри блоков. 

В нашем случае происходит следующее:

    // - этапы в коде 

1) //1 В области памяти типа Stack появляется фрейм `main` с полем `i` и значением `1`.
2) //2 В этом же фрейме появляется поле `o` в котором лежит ссылка на ячейку в области памяти "куча", где
лежит сам объект Object.
3) //3 Создаётся поле `ii` в котором лежит ссылка на ячейку в куче с содержимым Integer.
4) //4 Создаётся новый фрейм `printAll` в котором создаются поля 
    1) `o` содержащем ссылку на содержимое ячейки в куче, хранящей Object из пункта 2
    2) `i` со значением `1`
    3) `ii` содержащем ссылку на содержимое ячейки в куче, хранящей Integer из пункта 3
    4)  //7 `uselessVar` содержащем ссылку на содержимое ячейки в куче, хранящей Integer
    
5) Создаётся новый фрейм `println` 
6) Создаётся фрейм `toString`, который освобождается из памяти после того, как вернёт значение в место вызова
7) Освобождается фрейм `println`. Переменные внутри фрейма освобождают память.
8) Освобождается фрейм `printAll`. Переменные внутри фрейма освобождают память. Объекты из пункта 
   4i и 4iii остаются в памяти, но уничтожаются поля в фрейме содержащие ссылки на эти объекты.
   Содержимое переменной `uselessVar` уничтожается вместе с полем
   
9) //7 Создаётся фрейм `println`. После выполнения освобождает стэк.
10) фрейм `main` освобождает стэк.
11) Программа завершается, Garbage Collector освобождает всю занятую память после выполнения программы. (**хотя тут я не совсем понял, GC освобождает только кучу. А что осбовождает metaspace?**)


